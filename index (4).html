<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Hydra Sublenguaje - Rótulos Mexicanos</title>
  <script src="https://unpkg.com/hydra-synth"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: black;
      font-family: sans-serif; /* Unificar la fuente */
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }

    #input {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 600px;
      height: 80px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 18px;
      border: 2px solid white;
      border-radius: 10px;
      padding: 10px;
      z-index: 10;
      backdrop-filter: blur(4px);
      resize: none;
      box-sizing: border-box; /* Para que el padding no afecte el width/height */
    }

    #instructions {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 10px;
      font-family: sans-serif;
      max-width: 80%;
      z-index: 5;
      text-align: center;
      backdrop-filter: blur(4px);
    }

    #instructions p {
      margin: 5px 0;
    }

    #instructions ul {
      text-align: left;
      margin: 10px 0;
      padding-left: 20px;
    }

    #instructions li {
      margin-bottom: 5px;
    }
    #instructions li strong {
      color: #FFD700; /* Un color dorado para resaltar */
    }

    #displayText {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white; /* Color del texto */
      font-size: 8vw; /* Tamaño de fuente relativo al ancho de la ventana */
      font-family: 'Arial Black', sans-serif; /* Fuente impactante */
      text-shadow: 2px 2px 5px rgba(0,0,0,0.8); /* Sombra para que destaque */
      z-index: 1; /* Para que esté por encima del canvas pero debajo de las instrucciones/input */
      text-align: center;
      pointer-events: none; /* Permite hacer clic a través del texto */
      max-width: 90vw; /* Asegura que el texto no se desborde */
      word-wrap: break-word; /* Rompe palabras largas */
      opacity: 0.8; /* Ligeramente transparente */
    }
  </style>
</head>
<body>
  <div id="instructions">
    <p>¡Bienvenido al **Sublenguaje Hydra de Rótulos Mexicanos**!</p>
    <p>Escribe nombres de negocios y observa su estética visual. ¡Pinta con palabras!</p>
    <ul>
      <li>**Comida:** <strong>polleria</strong>, <strong>carniceria</strong>, <strong>tortilleria</strong>, <strong>taqueria</strong>, <strong>tostadas</strong>, <strong>elotes</strong>, <strong>barbacoa</strong>, <strong>carnitas</strong>, <strong>birria</strong>, <strong>esquites</strong>, <strong>panaderia</strong>, <strong>loncheria</strong>, <strong>pizzeria</strong>, <strong>tamales</strong>.</li>
      <li>**Belleza y Cuidado:** <strong>estetica</strong>, <strong>peluqueria</strong>, <strong>barberia</strong>, <strong>unas</strong>, <strong>spa</strong>.</li>
      <li>**Servicios:** <strong>cibercafe</strong>, <strong>copias</strong>, <strong>papeleria</strong>, <strong>reparaciondecelulares</strong>, <strong>vulcanizadora</strong>, <strong>talachas</strong>, <strong>herreria</strong>, <strong>plomeria</strong>, <strong>electricidad</strong>.</li>
      <li>**Comercios:** <strong>abarrotes</strong>, <strong>miscelanea</strong>, <strong>tienda</strong>, <strong>super</strong>, <strong>fruteria</strong>, <strong>verduleria</strong>.</li>
      <li>**Experimenta combinaciones:** Separa con **espacios** para mezclar (ej: `polleria miscelanea`), con **comas (,)** para modular (ej: `carnitas, estetica`), o con **'x'** para escalar (ej: `cibercafe x papeleria`).</li>
    </ul>
    <p>¡Explora la ciudad con tus palabras y crea visuales únicos!</p>
  </div>

  <textarea id="input" placeholder="Escribe aquí tu secuencia... (ej: taqueria, elotes x estetica)"></textarea>

  <div id="displayText"></div>

  <script>
    // Se cambia detectAudio a true para que la función 'magt' pueda usar el análisis de audio
    const hydra = new Hydra({ detectAudio: true });

    const palabras = {
      // --- Comida Típica Mexicana ---
      polleria: () => osc(6, 0.2, 1.5) // Formas simples, colores cálidos (rojo/amarillo/naranja)
        .color(1, 0.5, 0) // Naranja pollo asado
        .modulate(noise(2, 0.1), 0.5)
        .luma(0.5, 0.1),

      carniceria: () => noise(8, 0.5, 2) // Textura "cárnica" o marmoleada, colores rojizos
        .color(0.8, 0.2, 0.1) // Rojo carne
        .pixelate(20, 20)
        .diff(osc(1, 0.2, 0)),

      tortilleria: () => osc(3, 0.5, 1) // Patrones que recuerdan las tortillas, movimiento circular
        .color(0.9, 0.8, 0.5) // Amarillo maíz
        .rotate(() => time * 0.05)
        .modulate(voronoi(1, 0.1, 0.2), 0.1),

      taqueria: () => osc(10, 0.5, 2) // Colores vivos de salsas y verduras, elementos repetitivos
        .color(1, 0.3, 0.1) // Rojo salsa
        .add(osc(5, 0.1, 0.5).color(0.2, 0.8, 0.1), 0.5) // Verde cilantro/limón
        .kaleid(7)
        .blend(noise(0.5).luma(0.5)),

      tostadas: () => shape(4, 0.5, 0.9) // Cuadrados o rectángulos (forma de tostada), crujientes
        .color(0.9, 0.7, 0.4) // Dorado tostada
        .pixelate(30, 30)
        .modulate(noise(15, 0.1), 0.3), // Efecto crujiente

      elotes: () => voronoi(2, 0.5, 0.8) // Granos de elote, colores de mayonesa/queso/chile
        .color(0.9, 0.9, 0.1) // Amarillo maíz
        .add(osc(1, 0, 0.1).color(0.9, 0.1, 0.1), 0.5) // Rojo chile
        .diff(noise(0.5, 0.1).luma(0.5)), // Textura de los granos

      barbacoa: () => noise(15, 0.6, 0.3) // Textura ahumada, tonos terrosos y rojizos
        .color(0.6, 0.3, 0.1)
        .modulate(osc(1, 0.1, 0.1).rotate(0.1), 0.8)
        .luma(0.3, 0.1),

      carnitas: () => noise(8, 0.5, 2) // Textura "grasosa" o con puntos, colores anaranjados
        .color(0.8, 0.3, 0.1)
        .pixelate(20, 20)
        .diff(osc(1, 0.2, 0)), // Efecto de fritura

      birria: () => osc(7, 0.3, 1) // Colores rojizos oscuros, profundidad, algo de textura
        .color(0.7, 0.1, 0.1)
        .modulate(noise(3, 0.2), 0.5)
        .scale(0.95),

      esquites: () => voronoi(3, 0.5, 0.7) // Similares a elotes, pero quizás más mezclados
        .color(0.8, 0.8, 0.2) // Amarillo elote
        .add(noise(0.2, 0.1).color(0.7, 0.7, 0.7), 0.5) // Queso y mayonesa
        .blend(osc(10).color(1,0,0), 0.3), // Toque de chile

      panaderia: () => voronoi(2, 0.8, 0.2) // Formas "esponjosas", colores de pan y masas
        .color(0.9, 0.6, 0.3)
        .modulate(osc(0.5, 0.1, 0.5), 0.3)
        .scale(0.8),

      loncheria: () => shape(3, 0.5, 0.8) // Formas simples y sólidas, colores cotidianos
        .color(0.5, 0.7, 0.3)
        .modulate(noise(0.5, 0.1), 0.2)
        .pixelate(10,10),

      pizzeria: () => osc(4, 0.5, 0.9) // Círculos, colores de ingredientes, algo de movimiento
        .color(1, 0.4, 0) // Base de pizza
        .add(osc(10, 0.1, 0.5).color(0.8, 0.1, 0.1), 0.7) // Tomate/pepperoni
        .kaleid(8)
        .rotate(() => time * 0.02),

      tamales: () => noise(4, 0.2, 0.5) // Textura de hoja de maíz, colores de masa y rellenos
        .color(0.7, 0.6, 0.4)
        .modulate(osc(1, 0.1, 0.1).rotate(0.05), 0.5),

      // --- Belleza y Cuidado Personal ---
      estetica: () => osc(8, 0.5, 0.8) // Colores vibrantes, movimiento, brillo
        .color(() => Math.sin(time * 0.5) * 0.5 + 0.5, 0.2, 0.7) // Colores cambiantes
        .modulate(noise(1, 0.1).pixelate(5, 5), 0.7)
        .scale(() => 1 + Math.sin(time * 0.2) * 0.1)
        .rotate(0.01),

      peluqueria: () => osc(15, 0.1, 0.2) // Patrones finos como cabello, movimiento de tijeras
        .color(0.4, 0.2, 0.6) // Tonos de cabello/salón
        .modulate(noise(20, 0.5), 0.8)
        .scrollX(0.005),

      barberia: () => shape(3, 0.9, 0.1) // Líneas rectas, contrastes, colores clásicos (rojo, blanco, azul)
        .color(0.8, 0.1, 0.1) // Rojo
        .add(shape(3, 0.9, 0.1).color(1, 1, 1), 0.5) // Blanco
        .add(shape(3, 0.9, 0.1).color(0.1, 0.1, 0.8), 0.5) // Azul
        .rotate(() => time * 0.01),

      unas: () => voronoi(5, 0.1, 0.9) // Patrones pequeños y detallados, colores de esmaltes
        .color(1, 0.5, 0.7) // Rosa vibrante
        .modulate(osc(2, 0.1, 0.1), 0.5)
        .pixelate(8, 8),

      spa: () => osc(0.5, 0.1, 0.5) // Movimiento suave, colores relajantes, efectos acuáticos
        .color(0.2, 0.7, 0.6) // Verde agua
        .modulate(noise(0.1, 0.1), 0.9)
        .scrollX(() => Math.sin(time * 0.05) * 0.001),

      // --- Tecnología y Servicios ---
      cibercafe: () => noise(10, 0.8, 0.1) // Píxeles, ruido digital, colores fríos (azul/verde)
        .color(0.2, 0.7, 0.9)
        .pixelate(50, 50)
        .modulate(osc(15, 0.1, 0.1), 0.3)
        .luma(0.2, 0.1),

      copias: () => osc(20, 0.05, 0) // Líneas, monocromático, efecto de tinta
        .color(0.1, 0.1, 0.1)
        .pixelate(100, 100)
        .modulate(noise(0.5, 0.1), 0.05), // Pequeñas imperfecciones

      papeleria: () => shape(6, 0.8, 0.2) // Formas geométricas, limpieza, colores primarios
        .color(0.1, 0.4, 0.9) // Azul cuaderno
        .mult(shape(3, 0.5, 0.5).color(0.9, 0.2, 0.1)) // Rojo lápiz
        .modulate(osc(0.1, 0.1, 0.1), 0.1)
        .scale(1.1),

      reparaciondecelulares: () => noise(50, 0.1, 0) // Pixeles rotos, colores de circuitos, efecto de falla
        .color(0.1, 0.8, 0.1) // Verde circuito
        .pixelate(100, 50)
        .modulate(osc(100, 0.1, 0.1).luma(0.5), 0.9),

      vulcanizadora: () => shape(4, 0.9, 0.1) // Llantas/círculos, colores oscuros, textura de hule
        .color(0.2, 0.2, 0.2)
        .rotate(() => time * 0.03)
        .modulate(noise(2, 0.5), 0.6),

      talachas: () => noise(10, 0.3, 0.2) // Efecto de chispas, metal, trabajo rudo
        .color(0.7, 0.5, 0.1) // Tonos metálicos
        .add(osc(50, 0, 0).color(1, 0.5, 0.1), 0.2) // Chispas
        .pixelate(10, 10),

      herreria: () => noise(7, 0.6, 0.5) // Textura de metal forjado, chispas, rojo fuego
        .color(0.4, 0.1, 0.1) // Rojo oscuro
        .add(osc(100, 0, 0).color(1, 0.7, 0.1), 0.3) // Chispas/fuego
        .kaleid(3),

      plomeria: () => osc(0.8, 0.1, 0.9) // Movimiento de agua, colores de tuberías
        .color(0.1, 0.5, 0.7) // Azul agua
        .modulate(noise(0.5, 0.5), 0.8)
        .scrollX(0.002),

      electricidad: () => osc(20, 0.9, 0.1) // Rayos, chispas, colores eléctricos
        .color(0.1, 0.9, 0.9) // Azul eléctrico
        .modulate(noise(50, 0.1), 0.9)
        .diff(osc(100, 0.1, 0.1).color(1, 1, 0)), // Chispas amarillas

      // --- Comercios Generales ---
      abarrotes: () => noise(3, 0.5, 0.8) // Textura de empaques, colores variados y densos
        .color(0.8, 0.5, 0.1)
        .add(osc(5, 0.1, 0.1).color(0.1, 0.6, 0.2), 0.4)
        .pixelate(15, 15),

      miscelanea: () => shape(4, 0.5, 0.9) // Cuadrados, algo desordenado, muchos colores
        .rotate(() => Math.sin(time * 0.1) * 0.5)
        .color(() => Math.random(), () => Math.random(), () => Math.random())
        .modulate(noise(1, 0.5), 0.2)
        .scale(1.2),

      tienda: () => osc(5, 0.5, 0.5) // Patrón repetitivo como un logo simple, colores sólidos
        .color(0.6, 0.2, 0.8)
        .modulate(noise(1, 0.1), 0.1),

      super: () => voronoi(4, 0.1, 0.9) // Patrones más grandes, colores brillantes de publicidad
        .color(0.1, 0.9, 0.3)
        .add(osc(20, 0.1, 0.1).color(0.9, 0.1, 0.1), 0.5)
        .pixelate(40, 40),

      fruteria: () => osc(7, 0.5, 0.5) // Colores vivos de frutas, patrones orgánicos
        .color(1, 0.7, 0) // Naranja fruta
        .add(osc(5, 0.1, 0.5).color(0.2, 0.8, 0.1), 0.5) // Verde hoja
        .kaleid(5)
        .blend(noise(0.5).luma(0.5)),

      verduleria: () => noise(4, 0.8, 0.2) // Textura de hojas, colores verdes y terrosos
        .color(0.1, 0.6, 0.2) // Verde verdura
        .modulate(osc(0.5, 0.1, 0.1), 0.3)
        .scale(0.9),

      // Tu función magt (ahora con detectAudio: true)
      magt: () => {
        osc(40,0.5,() => a.fft[0]*200).out(o2)
        let shape = osc(60, 0.1, 2)
          .mult(noise(1, 4))
          .rotate(() => (Math.random() - 0.5) * 0.5 + Math.sin(time * 0.2) * 0.2)
        shape.out(o0)
        return shape
      },
    };

    const input = document.getElementById("input");
    const displayText = document.getElementById("displayText"); // Obtener referencia al nuevo div

    input.addEventListener("input", () => {
      const texto = input.value.toLowerCase().trim();

      // Mostrar el texto directamente en el div
      displayText.textContent = input.value;

      let modulationType = null;

      if (texto.includes(",")) {
        modulationType = 'modulate';
      } else if (texto.includes("x")) {
        modulationType = 'modulateScale';
      }

      // Lógica para modulaciones encadenadas
      if (modulationType) {
        const modWords = texto.split(/[,x]/).map(w => w.trim()).filter(w => palabras[w]);
        if (modWords.length >= 2) {
          let base = palabras[modWords[0]]();
          for (let i = 1; i < modWords.length; i++) {
            const modulator = palabras[modWords[i]]();
            const randomAmount = 0.5 + 0.3 * Math.random();

            if (modulationType === 'modulate') {
              base = modulator.modulate(base, randomAmount);
            } else if (modulationType === 'modulateScale') {
              base = modulator.modulateScale(base, randomAmount);
            }
          }
          base.out();
          return;
        }
      }

      // Si no hubo modulación encadenada, renderiza en capas independientes
      const entradas = texto.split(/\s+/).map(w => w.trim()).filter(w => palabras[w]);
      if (entradas.length > 0) {
        let comp = palabras[entradas[0]]();
        for (let i = 1; i < entradas.length; i++) {
          comp = comp.diff(palabras[entradas[i]](), 0.5);
        }
        comp.out();
      } else {
        // Si no hay entrada válida o se borra el texto, limpiar el lienzo y el texto visible
        osc(0, 0, 0).out();
        displayText.textContent = "";
      }
    });
  </script>
</body>
</html>
